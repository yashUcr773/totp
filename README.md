# Time-Based One-Time Password (TOTP) – Custom Implementation in Node.js

This project is a complete, dependency-free implementation of TOTP (RFC 6238) in Node.js — the same standard used by Google Authenticator, Microsoft Authenticator, Authy, and most 2FA systems. Only low level crypto library is used.

This project includes

1. Secure secret generation
2. Base32 encoding & decoding
3. TOTP generation
4. TOTP verification with clock drift handling
5. otpauth:// URI generation for QR codes

## What is TOTP?

Two-factor authentication (2FA) is now a standard security requirement for modern applications. One of the most widely used methods is TOTP - Time-Based One-Time Passwords. TOTP (Time-Based One-Time Password) is a 6-digit temporary code that changes every 30 seconds.

It is used for Two-Factor Authentication (2FA) and is based on:

- A shared secret key
- The current Unix timestamp
- HMAC-SHA1 hashing

This is defined in RFC 6238 and is an extension of HOTP (RFC 4226).

## How TOTP Works (High Level)

1. Your server generates a random secret key.
2. The secret is stored in your database in an encrypted form.
3. The secret is added to the user's authenticator app using a QR code.
4. Every 30 seconds:
   1. The phone generates a 6-digit code.
   2. The server generates the same code.
5. If both match → authentication succeeds.

No network connection is required between phone and server.

## TOTP Algorithm (High Level)

1. Decode Base32 secret into raw bytes
2. Convert current time into a counter (30-second window)
3. Convert counter into an 8-byte buffer
4. Compute HMAC-SHA1(secret, counter)
5. Perform dynamic truncation
6. Reduce result to a 6-digit number

## Implementation

### 1. Constants

```javascript
const STEP = 30; // Time step in seconds
const DIGITS = 6; // Number of OTP digits
const BASE32 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
```

### 2. Secure Secret Generation

TOTP requires a cryptographically secure random secret. We use Node’s built-in `crypto.randomBytes()`.

Why random bytes?

1. Generated by OS secure entropy pool
2. Unpredictable
3. Safe for cryptographic use
4. Standard for key generation

```javascript
import { randomBytes } from 'crypto';

/**
 * Generates cryptographically secure random bytes
 */
export function generateSecretBytes(length = 20) {
  return randomBytes(length);
}
```

### 3. Base32 Encoding

Authenticator apps expect secrets in Base32 (RFC 4648) format. So we need to convert the generated random bytes to Base32 string.

Why Base32?

1. Human friendly (no 0/O/I/l confusion)
2. QR-code friendly
3. URL safe
4. Industry standard

```javascript
/**
 * Encodes a Buffer into a Base32 string (RFC 4648)
 */
export function base32Encode(buf) {
  let bits = 0;
  let value = 0;
  let output = '';

  for (const byte of buf) {
    value = (value << 8) | byte;
    bits += 8;

    while (bits >= 5) {
      output += BASE32[(value >>> (bits - 5)) & 31];
      bits -= 5;
    }
  }

  if (bits > 0) {
    output += BASE32[(value << (5 - bits)) & 31];
  }

  return output;
}
```

### 4.Base32 Decoding

Before computing TOTP, we must convert the Base32 secret back into raw bytes.

```javascript
/**
 * Decodes a Base32 string into a Buffer
 */
export function base32Decode(str) {
  const clean = str
    .toUpperCase()
    .replace(/=+$/, '')
    .replace(/[^A-Z2-7]/g, '');

  let bits = 0;
  let value = 0;
  const bytes = [];

  for (const char of clean) {
    const index = BASE32.indexOf(char);
    value = (value << 5) | index;
    bits += 5;

    if (bits >= 8) {
      bytes.push((value >>> (bits - 8)) & 0xff);
      bits -= 8;
    }
  }

  return Buffer.from(bytes);
}
```

### 5.TOTP Generation

This function implements the official RFC 6238 algorithm.

```javascript
import { createHmac } from 'crypto';

/**
 * Generates a 6-digit TOTP code for the given secret and time
 */
export function totp(secret, timeSeconds = Math.floor(Date.now() / 1000)) {
  const counter = Math.floor(timeSeconds / STEP);

  // Convert counter to 8-byte big-endian buffer
  const buffer = Buffer.alloc(8);
  let temp = counter;

  for (let i = 7; i >= 0; i--) {
    buffer[i] = temp & 0xff;
    temp >>= 8;
  }

  // HMAC-SHA1(secret, counter)
  const hmac = createHmac('sha1', secret).update(buffer).digest();

  // Dynamic truncation
  const offset = hmac[hmac.length - 1] & 0x0f;

  const binary =
    ((hmac[offset] & 0x7f) << 24) |
    ((hmac[offset + 1] & 0xff) << 16) |
    ((hmac[offset + 2] & 0xff) << 8) |
    (hmac[offset + 3] & 0xff);

  // Reduce to 6 digits
  return (binary % 10 ** DIGITS).toString().padStart(DIGITS, '0');
}
```

### 6. TOTP Verification (With Clock Drift)

Phones and servers may be a few seconds apart. We verify within a time window (±1 or ±2 steps).

```javascript
/**
 * Verifies a user-provided TOTP token
 */
export function verifyTotp(secretBase32, token, window = 1) {
  const secret = base32Decode(secretBase32);
  const now = Math.floor(Date.now() / 1000);

  token = String(token).padStart(DIGITS, '0');

  for (let w = -window; w <= window; w++) {
    const expected = totp(secret, now + w * STEP);

    if (expected === token) {
      return { ok: true, drift: w };
    }
  }

  return { ok: false };
}
```

### 7.otpauth:// URI (For QR Codes)

Authenticator apps require a special URI format:

```javascript
otpauth://totp/{issuer}:{account}?secret=SECRET&issuer=ISSUER
```

```javascript
/**
 * Builds an otpauth URI for QR code generation
 */
export function buildOtpAuthUri({ secret, account, issuer }) {
  return `otpauth://totp/${encodeURIComponent(issuer)}:${encodeURIComponent(
    account
  )}?secret=${secret}&issuer=${encodeURIComponent(issuer)}&algorithm=SHA1&digits=6&period=30`;
}
```
